= Improvement Ideas
:toc:

This document records improvements identified through REPL exploration and API review.

== 1. Better Error Messages ✓

*Status:* DONE

*Original problem:*
Missing keys produced cryptic `NullPointerException`. Circular dependencies caused `StackOverflowError` with no indication of the cycle.

*Solution implemented:*

- Added `*unwrap-stack*` dynamic var to track keys being unwrapped
- Circular dependencies now throw `ex-info` with `:type :circular-dependency` and full cycle path
- Function wrapper errors now include context: key being computed, available keys, dependency chain

*Example of new behavior:*
[source,clojure]
----
(def m (fun-map {:a (fnk [b] b) :b (fnk [a] a)}))
(:a m)
;=> ExceptionInfo: Circular dependency detected: :a -> :b -> :a
;   {:type :circular-dependency, :key :a, :cycle [:a :b :a]}
----

== 2. Plain Maps Inside Fun-Maps Don't Unwrap

*Priority:* Low (documentation)

*Problem:*
Only fun-maps unwrap their values. Plain maps nested inside a fun-map do not unwrap:

[source,clojure]
----
(def m (fun-map {:a {:b (delay 42)}}))  ; {:b ...} is a plain map
(:b (:a m)) ;=> #object[clojure.lang.Delay ...]  ; not 42

;; With nested fun-map, it works:
(def m (fun-map {:a (fun-map {:b (delay 42)})}))
(get-in m [:a :b]) ;=> 42
----

*Status:* Documented in concepts.adoc. This is expected behavior, not a bug.

== 3. Iteration Triggers All Computations

*Priority:* Low (documentation)

*Problem:*
Iterating a fun-map (including `keys`, `vals`, `seq`, `reduce-kv`) triggers all computations. Side effects interleave with output:

[source,clojure]
----
(def m (fun-map {:a 1 :b (fnk [a] (println "computing") (* a 2))}))
(keys m)
;; prints: (:a computing
;;          :b)
----

*Suggestion:*
Document that iteration realizes all values. This is expected but may surprise users.

== 4. `select-keys` and `into` Lose Fun-Map Semantics

*Priority:* Low

*Problem:*
Standard Clojure functions return plain maps:

[source,clojure]
----
(def m (fun-map {:a 1 :b (fnk [a] (* a 2))}))
(type (select-keys m [:a :b])) ;=> clojure.lang.PersistentArrayMap
(type (into {} m))             ;=> clojure.lang.PersistentArrayMap
----

*Suggestion:*
Document as expected behavior (values are realized during iteration). Optionally provide `select-keys*` that preserves wrappers for advanced use cases.

== 5. `:keep-ref` Interaction with `fnk` Is Confusing

*Priority:* Medium

*Problem:*
With `:keep-ref true`, `fnk` receives the atom itself, not the dereferenced value. But `fnk` auto-generates focus on the *binding* (the atom), not its contents.

[source,clojure]
----
(def state (atom [1 2 3]))
(def m (fun-map {:nums state
                 :count (fnk [nums] (count nums))}  ; nums is atom, not vector!
                :keep-ref true))
(:count m) ;=> UnsupportedOperationException: count not supported on Atom
----

The correct pattern requires explicit `fw` with `@` in focus:
[source,clojure]
----
(fw {:keys [nums] :focus @nums}
  (count @nums))
----

*Suggestion:*

- Document this interaction explicitly in the API docs
- Consider a `:deref-focus` option for `fnk` that focuses on `@binding` instead of `binding`

== 6. Documentation: Missing "Gotchas" Section ✓

*Status:* DONE

*Solution:* Added comprehensive "Gotchas and Common Pitfalls" section to `doc/concepts.adoc` covering:

- Plain maps inside fun-maps don't unwrap
- Iteration realizes all values
- `select-keys` and `into` return plain maps
- `update` on computed keys replaces the fnk
- `dissoc` silently breaks dependencies
- `:keep-ref` + `fnk` interaction
- Printing shows wrapper state

== 7. `closeable` Could Support `with-open` ✓

*Status:* DONE

*Solution:* `CloseableValue` now implements `java.io.Closeable` in CLJ. Works with `with-open`:

[source,clojure]
----
(with-open [r (closeable (create-resource) #(cleanup))]
  (use-resource @r))  ; works!
----

== 8. core.cljc Improvements ✓

*Status:* DONE

Several issues were identified and fixed in `core.cljc`:

=== Fixed: `valAt` nil/false handling (High priority)

Both CLJ and CLJS `valAt`/`-lookup` with `not-found` incorrectly returned `not-found` when the computed value was `nil` or `false`.

*Solution:* Changed from `(or ... not-found)` to `(if-let [entry ...] (val entry) not-found)`.

=== Added: `IKVReduce` implementation (Low priority)

`reduce-kv` now uses native implementation instead of falling back to seq-based reduction.

=== Added: CLJS `TransientDelegatedMap` `ILookup` (Low priority)

CLJS transient fun-maps now support lookups during transient operations.

=== Documented: Hash/equals gotchas

- Equality comparison realizes all values
- Hash codes use underlying map (wrappers), not realized values

See `doc/concepts.adoc` for details.

== 9. wrapper.cljc Improvements ✓

*Status:* DONE

=== Fixed: `-unwrap` returned exception instead of throwing (Medium priority)

The `Object` and `nil` implementations of `-unwrap` returned an `ex-info` object instead of throwing it. Now properly throws if these code paths are ever hit (which indicates a bug).

=== Fixed: `CachedWrapper` race condition (Medium priority)

Moved focus-fn evaluation and staleness check inside `swap!` to avoid race condition where multiple threads could redundantly recompute cached values.

=== Added: `TracedWrapper` print method (Low priority)

Added `print-method` for `TracedWrapper` for consistency with `FunctionWrapper` and `CachedWrapper`.

=== Cleanup: Removed dead CLJS code (Low priority)

Removed unreachable `::-raw-seq-fn` metadata check in `raw-keys` CLJS branch.

=== Cleanup: Standardized docstrings (Low priority)

Standardized docstring style across `fun-wrapper`, `cache-wrapper`, and `trace-wrapper`.

== Implementation Status

[cols="1,3,1"]
|===
|ID |Description |Status

|1 |Better error messages |DONE
|2 |Document `get-in` limitation |DONE
|3 |Document iteration behavior |DONE
|4 |Document `select-keys`/`into` behavior |DONE
|5 |Document `:keep-ref` + `fnk` interaction |DONE
|6 |Add gotchas section |DONE
|7 |`Closeable` support for `closeable` |DONE
|8 |core.cljc improvements |DONE
|9 |wrapper.cljc improvements |DONE
|===
